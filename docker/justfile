set dotenv-load := true

export DOCKER_USERID := `id -u`
export DOCKER_GROUPID := `id -g`
export PYTEST_HOST_TMP := "/tmp/jobrunner-docker"

# the dev build needs to know the hosts docker group ID, to match it in the container

export DOCKER_HOST_GROUPID := `getent group docker | awk -F: '{print $3}'`

# dev builds remap's appuser's uid to the running user, for easy file
# permissions when we mount things in.

export DEV_USERID := `id -u`
export DEV_GROUPID := `id -g`

build env="dev": tmpdir
    #!/usr/bin/env bash
    set -eu

    # ensure env files exist
    test -f ../.env || cp ../dotenv-sample ../.env
    touch docker-compose.env

    # enable modern docker build features
    export DOCKER_BUILDKIT=1
    export COMPOSE_DOCKER_CLI_BUILD=1

    # set build args for prod builds
    export BUILD_DATE=$(date -u +'%y-%m-%dT%H:%M:%SZ')
    export GITREF=$(git rev-parse --short HEAD)

    # build the thing
    docker compose build --pull {{ env }}

tmpdir:
    #!/bin/bash
    # We do this in order to ensure that PYTEST_HOST_TMP is owned by the user running the tests
    if test -d $PYTEST_HOST_TMP; then
        rm $PYTEST_HOST_TMP -rf || { echo "Cannot create $PYTEST_HOST_TMP! Is it owned by root? If so, remove."; exit 1; }
    fi
    mkdir $PYTEST_HOST_TMP

# run tests in docker container
test *args: build
    #!/bin/bash
    docker compose run --rm test {{ args }}

# run dev server in docker container
service: build
    docker compose up dev

# run command in dev container
run env="dev" *args="bash": build
    docker compose run --rm {{ env }} {{ args }}

# exec command in existing dev container
exec *args="bash":
    docker compose exec dev {{ args }}

clean:
    #!/bin/bash
    rm -rf $PYTEST_HOST_TMP
    docker image rm job-runner job-runner-dev || true
